<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Textured Room – Inside View</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
    }
    canvas { display: block; }
    .hint {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #ddd;
      font-family: system-ui, sans-serif;
      font-size: 14px;
      text-align: center;
      background: rgba(0, 0, 0, 0.35);
      padding: 6px 10px;
      border-radius: 8px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset camera</div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // === 1) Scene ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // === 2) Camera ===
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    const defaultPos = new THREE.Vector3(0, 1.5, 3);
    camera.position.copy(defaultPos);
    camera.lookAt(0, 1, 0);

    // === 3) Renderer ===
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === 4) Controls ===
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);
    controls.minDistance = 0.5;
    controls.maxDistance = 10;

    // === 5) Lighting ===
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    const point = new THREE.PointLight(0xffffff, 1.0, 100);
    point.position.set(0, 2.4, 0);
    scene.add(ambient, point);

    // === 6) Texture loader + fallback ===
    const loader = new THREE.TextureLoader();
    function makeFallback(label) {
      const c = document.createElement('canvas');
      c.width = c.height = 256;
      const ctx = c.getContext('2d');
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(0, 0, 256, 256);
      ctx.fillStyle = '#999';
      ctx.font = '16px system-ui';
      ctx.fillText(label, 20, 130);
      return new THREE.CanvasTexture(c);
    }

    function safeLoad(path, label) {
      let tex = loader.load(
        path,
        () => { tex.needsUpdate = true; },
        undefined,
        () => { tex = makeFallback(label); }
      );
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const floorTex = safeLoad('floor.jpg', 'floor.jpg?');
    const wallTex = safeLoad('wall.jpg', 'wall.jpg?');
    const ceilingTex = safeLoad('ceiling.jpg', 'ceiling.jpg?');

    floorTex.repeat.set(2, 2);
    wallTex.repeat.set(1.5, 1);
    ceilingTex.repeat.set(1, 1);

    // === 7) Materials – BackSide (agar terlihat dari dalam) ===
    // [Perubahan] Sebelumnya menggunakan THREE.FrontSide, sekarang diganti ke THREE.BackSide.
    // Alasan: supaya permukaan bagian dalam ruangan terlihat saat kamera berada di dalam.
    const matFloor = new THREE.MeshStandardMaterial({ map: floorTex, side: THREE.BackSide });
    const matWall = new THREE.MeshStandardMaterial({ map: wallTex, side: THREE.BackSide });
    const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.BackSide });

    // === 8) Room Geometry ===
    const W = 4; // lebar
    const H = 3; // tinggi
    const D = 6; // panjang

    // [Perubahan] Sebelumnya enam dinding dibuat manual (PlaneGeometry per sisi + rotasi).
    // Sekarang diganti menjadi satu BoxGeometry agar lebih sederhana dan otomatis tertutup.
    const roomGeo = new THREE.BoxGeometry(W, H, D);

    // [Perubahan] Menentukan material untuk setiap sisi kotak.
    // Urutan sisi: +X, -X, +Y, -Y, +Z, -Z.
    const roomMat = [
      matWall,   // kanan
      matWall,   // kiri
      matCeiling, // atas
      matFloor,   // bawah
      matWall,   // depan
      matWall    // belakang
    ];

    // [Perubahan] Semua dinding, lantai, dan atap kini disatukan ke satu Mesh.
    const room = new THREE.Mesh(roomGeo, roomMat);
    scene.add(room);

    // === 9) Render Loop ===
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // === 10) Responsif resize ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // === 11) Reset kamera ===
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        // [Perubahan kecil] Menghapus camera.lookAt() karena OrbitControls sudah menangani orientasi kamera.
        camera.position.copy(defaultPos);
        controls.target.set(0, 1, 0);
        controls.update();
      }
    });
  </script>
</body>
</html>